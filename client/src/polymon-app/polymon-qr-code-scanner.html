<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../bower_components/meat-scope-elements/meat-scope-video.html">
<link rel="import" href="../../bower_components/meat-scope-elements/meat-scope-devices.html">
<link rel="import" href="../../bower_components/meat-scope-elements/meat-scope-user-media.html">
<link rel="import" href="../../bower_components/meat-scope-elements/meat-scope-film-strip.html">
<link rel="import" href="polymon-element.html">
<link rel="import" href="polymon-button.html">
<link rel="import" href="polymon-spinner.html">
<dom-module id="polymon-qr-code-scanner">
  <template strip-whitespace>
    <style>
      :host {
        @apply --layout-fit;
        @apply --layout-vertical;
        @apply --layout-center-center;
        font-family: var(--polymon-font-family);
        text-align: center;
        background-color: #000;
        opacity: 0;
        pointer-events: none;
        transform: translateY(10px);
        transition: transform 0.3s, opacity 0.15s;
        z-index: 3;
      }

      :host(.active) {
        opacity: 1;
        pointer-events: all;
        transform: translateY(0);
      }

      :host(.active) #fallback {
        opacity: 1;
        transform: translateY(-10px);
      }

      meat-scope-video {
        text-align: left;
      }

      #camera {
        @apply --layout-fit;
        pointer-events: none;
        z-index: 2;
      }

      #overlay {
        @apply --layout-fit;
        @apply --layout-horizontal;
        align-items: flex-end;
        margin: 1em;
        z-index: 4;
      }

      #cancel {
        width: 100%;
      }

      a {
        -webkit-tap-highlight-color: rgba(255, 255, 255, 0);
      }

      #fallback {
        @apply --layout-fit;
        @apply --layout-vertical;

        align-items: center;
        justify-content: center;
        z-index: 1;

        opacity: 0;
        transform: translateY(0);
        transition: transform 0.3s, opacity 0.15s;
        transition-delay: 1s;
      }

      #fallback .warning {
        margin: 2em 2em 0;
        display: inline-block;
        max-width: 640px;
        font-size: 24px;
        color: #F43865;
        text-shadow: 0 1px 0 #a31733;
      }

      #upload-container {
        flex: 1;
        margin-left: 1em;
        position: relative;
      }

      #upload-container > * {
        width: 100%;
      }

      #input {
        @apply --layout-fit;
        z-index: 2;
        opacity: 0;
      }

      :host(.has-code) #code-scanned-indicator {
        opacity: 1;
        transform: translateY(0px);
        pointer-events: all;
      }

      #code-scanned-indicator {
        @apply --layout-fit;
        @apply --layout-vertical;
        @apply --layout-center-center;

        opacity: 0;
        transform: translateY(10px);

        transition: opacity 0.3s, transform 0.3s;
        pointer-events: none;
        z-index: 3;
        background-color: rgba(0, 0, 0, 0.5);
      }
    </style>
    <section id="fallback">
      <span class="warning">Please enable your camera to scan for QR codes!</span>
    </section>
    <section id="camera">
      <meat-scope-devices
          id="devices"
          selected-camera="{{camera}}"
          has-multiple-cameras="{{hasMultipleCameras}}">
      </meat-scope-devices>
      <meat-scope-user-media
          id="media"
          device="[[camera]]"
          stream="{{stream}}">
      </meat-scope-user-media>
      <meat-scope-video
          id="video"
          stream="[[stream]]">
      </meat-scope-video>
    </section>
    <section id="code-scanned-indicator">
      <polymon-spinner></polymon-spinner>
    </section>
    <section id="overlay">
      <a href="[[returnTo]]">
        <polymon-button
            id="cancel"
            class="alt">Cancel</polymon-button>
      </a>
      <div id="upload-container">
        <polymon-button>Upload a QR Code Photo</polymon-button>
        <!-- NOTE(valdrin) the `capture` attribute causes Android to directly
         open the camera instead of asking the user to choose between camera or
         the photo library -->
        <input id="input" type="file" accept="image/*">
      </div>
    </section>
  </template>
  <script>
    Polymer({
      is: 'polymon-qr-code-scanner',

      behaviors: [PolymonElement],

      properties: {
        returnTo: {
          type: String,
          notify: true
        },

        imagePreview: {
          type: Object,
          value: function() {
            return new MeatScopeImagePreview();
          }
        },

        urlRe: {
          type: Object,
          value: /^http[s]?:\/\//
        },

        polymonCodeRe: {
          type: Object,
          value: /^[a-z]+\..+/
        },

        originRe: {
          type: Object,
          value: new RegExp(`^${window.location.origin}/code/(.*)`)
        },

        uploadedImageUrl: {
          type: Object,
          readOnly: true,
          value: null,
          observer: '__uploadedImageUrlChanged'
        },

        code: {
          type: Object,
          readOnly: true,
          value: null,
          observer: '__codeChanged'
        },
      },

      observers: [
        '__cameraChanged(camera, hasMultipleCameras)',
        '__activeChanged(active)'
      ],

      listeners: {
        'input.change': '__onInputChange'
      },

      __uploadedImageUrlChanged: function(uploadedImageUrl, oldUploadedImageUrl) {
        if (oldUploadedImageUrl != null) {
          try {
            URL.revokeObjectURL(oldUploadedImageUrl);
          } catch (e) {}
        }
        if (uploadedImageUrl) {
          // Disable the camera while processing the image.
          this.stopScanning();
          this.__captureFromUploadedImage()
            .catch(error => this.__showError('QR Code scan failed:', error))
            .then(() => {
              // Reset the fallback file input:
              this.$.input.value = null;
              // Unset the uploaded image URL if one exists:
              this._setUploadedImageUrl(null);
              // Restart scanning.
              this.scan();
            });
        }
      },

      __onInputChange: function() {
        let file = this.$.input.files[0];
        if (file != null) {
          this._setUploadedImageUrl(URL.createObjectURL(file));
        }
      },

      get ownerHost() {
        let root = Polymer.dom(this).getOwnerRoot();
        return (root && root.host) || document;
      },

      ready: function() {
        this.__updateVideoDisplay();
      },

      attached: function() {
        this.__ownerHost = this.ownerHost;
        this.listen(this.__ownerHost,
            'polymon-qr-code-scanner-activate', '__onActivateRequest');
        this.listen(this.__ownerHost,
            'polymon-qr-code-scanner-deactivate', '__onDeactivateRequest');
      },

      detached: function() {
        this.unlisten(this.__ownerHost,
            'polymon-qr-code-scanner-activate', '__onActivateRequest');
        this.unlisten(this.__ownerHost,
            'polymon-qr-code-scanner-deactivate', '__onDeactivateRequest');
        this.__ownerHost = null;
      },

      scan: function() {
        this.$.media.active = true;
        // Wait a second, then check if can scan.
        this.debounce('scan', () => {
          if (!this.$.media.active) {
            return;
          }
          // If we have a stream, capture, else we just wait for another second.
          const capturePromise = this.stream ? this.__captureFromCamera() : Promise.resolve();
          capturePromise
            .catch(error => this.__showError('QR Code scan failed:', error))
            .then(() => this.scan());
        }, 1000);
      },

      stopScanning: function() {
        console.log('STOP SCANNING');

        // Stop any debouncer that might change `active`.
        this.cancelDebouncer('activeChanged');
        this.cancelDebouncer('scan');

        // Stop the media stream:
        this.$.media.active = false;
        // Clear the video src, blacking it out:
        this.$.video.$.video.src = null;
        // Unset the scanned code if one exists:
        this._setCode(null);
      },

      __codeChanged: function(code) {
        if (code != null) {
          this.$.media.active = false;
          this.fire('polymon-code', code);
          this.classList.add('has-code');
        } else {
          this.classList.remove('has-code');
        }
      },

      __onActivateRequest: function(event) {
        this.returnTo = event.detail.returnTo;
        if (event.detail.handledCallback) {
          event.detail.handledCallback();
        }
        this.active = true;
      },

      __onDeactivateRequest: function(event) {
        this.active = false;
      },

      __activeChanged: function() {
        this.debounce('activeChanged', () => {
          if (this.active) {
            this.listen(window, 'focus', '__windowFocusChanged');
            this.listen(window, 'blur', '__windowFocusChanged');
            this.scan();
          } else {
            this.unlisten(window, 'focus', '__windowFocusChanged');
            this.unlisten(window, 'blur', '__windowFocusChanged');
            this.stopScanning();
          }
        }, 300);
      },

      __captureFromCamera: function() {
        return new Promise((resolve, reject) => {
          let captureRect = new MeatScopeCaptureRect(this.$.video);

          this.imagePreview.draw(
              this.$.video.$.video,
              captureRect,
              new MeatScopeTransform());

          try {
            resolve(this.__process(this.imagePreview, captureRect));
          } catch (e) {
            reject(e);
          }
        })
          .then(data => this.__saveQRCode(data));
      },

      __captureFromUploadedImage: function() {
        return new Promise((resolve, reject) => {
          let image = document.createElement('img');
          // NOTE(cdata): scale, x and y are here to trick the meat scope
          // elements into thinking this is a <meat-scope-video>. Tiz a dirty
          // hack to be sure, but allows us to re-use the canvas processing
          // in the MeatScopeImagePreview instance for better performance.
          image.scale = 1;
          image.x = 0;
          image.y = 0;
          image.crossOrigin = "Anonymous";

          image.onload = event => {
            let captureRect = new MeatScopeCaptureRect(
                image, 600, 0, 0, image.width, image.height);

            this.imagePreview
                .draw(image, captureRect, new MeatScopeTransform());

            try {
              resolve(this.__process(this.imagePreview, captureRect));
            } catch (e) {
              reject(e);
            }
          };

          image.src = this.uploadedImageUrl;
        })
        .then(data => this.__saveQRCode(data));
      },

      __process: function(imagePreview, captureRect) {
        // Lazy load the QR Code reader library.
        // NOTE(cdata): For some reason, if this loads at the same time as the
        // map, the map will not render. This is kind of crazy, and it deserves
        // to be looked into more deeply. For now, lazy loading addresses the
        // problem except in the condition when the user refreshes while using
        // the scanner (probably rare, but who knows).
        if (this.__qrCodeLibraryLoads == null) {
          this.__qrCodeLibraryLoads = new Promise((resolve, reject) => {
            this.importHref(this.resolveUrl('third-party/jsqrcode.html'),
                event => resolve(), error => reject(error));
          });
        }

        return this.__qrCodeLibraryLoads.then(() => {
          qrcode.width = captureRect.clampedWidth;
          qrcode.height = captureRect.clampedHeight;
          qrcode.imagedata = imagePreview.context
          .getImageData(0, 0, qrcode.width, qrcode.height);

          return qrcode.process(imagePreview.context);
        });
      },

      /**
       * Parses and saves `data` into `code`, throws an error if `data` is
       * not valid.
       */
      __saveQRCode: function(data) {
        let validData;
        if (this.urlRe.test(data)) {
          const [url, fragment] = data.match(this.originRe) || [];
          validData = fragment;
        } else if (this.polymonCodeRe.test(data)){
          validData = data;
        }
        if (validData) {
          const [type, code] = validData.split('.');
          this._setCode({
            type,
            code,
            continueTo: this.returnTo
          });
        } else {
          throw new Error('Cannot use QR Code data');
        }
      },

      // TODO implement ui to show error to user
      __showError: function(title, error) {
        console.error(title, error);
      },

      __windowFocusChanged: function(event) {
        if (event.type === 'focus') {
          this.scan();
        } else {
          this.stopScanning();
        }
      },


      __cameraChanged: function(camera) {
        this.__updateVideoDisplay();
        if (!camera) {
          return;
        }
        if (!/environment|rear|back/i.test(camera.label) &&
            this.$.devices.hasMultipleCameras) {
          this.$.devices.switchToNextCamera();
        }
      },

      __updateVideoDisplay: function() {
        // On iOs 10 safari displays the Play button of the <video> tag inside
        // <meat-scope-video> even if it is visibility: hidden, so we fix it by
        // displaying the element when we have the camera.
        // TODO remove this method when/if meat-scope-video fixes it.
        this.$.video.style.display = this.camera ? '' : 'none';
      }
    });
  </script>
</dom-module>
